// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

module AESTL(
  input         clock,
                reset,
                auto_in_a_valid,
  input  [2:0]  auto_in_a_bits_opcode,
  input  [1:0]  auto_in_a_bits_size,
  input  [8:0]  auto_in_a_bits_source,
  input  [30:0] auto_in_a_bits_address,
  input  [7:0]  auto_in_a_bits_mask,
  input  [63:0] auto_in_a_bits_data,
  input         auto_in_d_ready,
  output        auto_in_a_ready,
                auto_in_d_valid,
  output [2:0]  auto_in_d_bits_opcode,
  output [1:0]  auto_in_d_bits_size,
  output [8:0]  auto_in_d_bits_source,
  output [63:0] auto_in_d_bits_data
);

  wire [127:0]      _impl_o_cipher_AES;	// @[AES.scala:76:20]
  wire              _impl_o_finish;	// @[AES.scala:76:20]
  reg  [63:0]       ikey0;	// @[AES.scala:66:19]
  reg  [63:0]       ikey1;	// @[AES.scala:67:19]
  reg  [63:0]       imsg0;	// @[AES.scala:68:19]
  reg  [63:0]       imsg1;	// @[AES.scala:69:19]
  reg               rst_r;	// @[AES.scala:79:20]
  reg               init_r;	// @[AES.scala:80:20]
  reg               mode_r;	// @[AES.scala:81:20]
  reg               enc_r;	// @[AES.scala:82:20]
  reg               active_r;	// @[AES.scala:84:25]
  reg  [3:0]        counter_r;	// @[AES.scala:85:26]
  reg  [2:0]        state;	// @[AES.scala:89:22]
  wire              out_front_bits_read = auto_in_a_bits_opcode == 3'h4;	// @[AES.scala:103:13, RegisterRouter.scala:72:36]
  wire              _out_out_bits_data_WIRE_8 = auto_in_a_bits_address[11:7] == 5'h0;	// @[Edges.scala:192:34, RegisterRouter.scala:73:19, :83:24]
  wire              _out_wofireMux_T_2 = auto_in_a_valid & auto_in_d_ready & ~out_front_bits_read;	// @[RegisterRouter.scala:72:36, :83:24]
  wire [15:0]       _GEN = {{1'h1}, {1'h1}, {1'h1}, {1'h1}, {1'h1}, {1'h1}, {1'h1}, {_out_out_bits_data_WIRE_8}, {_out_out_bits_data_WIRE_8}, {_out_out_bits_data_WIRE_8}, {_out_out_bits_data_WIRE_8}, {_out_out_bits_data_WIRE_8}, {_out_out_bits_data_WIRE_8}, {_out_out_bits_data_WIRE_8}, {_out_out_bits_data_WIRE_8}, {_out_out_bits_data_WIRE_8}};	// @[AES.scala:102:28, MuxLiteral.scala:49:10, RegisterRouter.scala:83:24]
  wire [15:0][63:0] _GEN_0 = {{64'h0}, {64'h0}, {64'h0}, {64'h0}, {64'h0}, {64'h0}, {64'h0}, {_impl_o_cipher_AES[127:64]}, {_impl_o_cipher_AES[63:0]}, {64'h0}, {64'h0}, {64'h0}, {64'h0}, {{63'h0, _impl_o_finish}}, {64'h0}, {64'h0}};	// @[AES.scala:76:20, :133:37, :134:37, MuxLiteral.scala:49:{10,48}, RegisterRouter.scala:83:24]
  wire              _rst_r_T = state == 3'h0;	// @[AES.scala:89:22, :91:15]
  wire              _enc_r_T = state == 3'h2;	// @[AES.scala:89:22, :95:13, :113:26]
  wire [63:0]       out_backMask = {{8{auto_in_a_bits_mask[7]}}, {8{auto_in_a_bits_mask[6]}}, {8{auto_in_a_bits_mask[5]}}, {8{auto_in_a_bits_mask[4]}}, {8{auto_in_a_bits_mask[3]}}, {8{auto_in_a_bits_mask[2]}}, {8{auto_in_a_bits_mask[1]}}, {8{auto_in_a_bits_mask[0]}}};	// @[Bitwise.scala:28:17, :77:12, Cat.scala:33:92]
  always @(posedge clock) begin
    if (_out_wofireMux_T_2 & auto_in_a_bits_address[6:3] == 4'h3 & _out_out_bits_data_WIRE_8 & (&out_backMask))	// @[Cat.scala:33:92, OneHot.scala:57:35, RegisterRouter.scala:83:24]
      ikey0 <= auto_in_a_bits_data;	// @[AES.scala:66:19]
    if (_out_wofireMux_T_2 & auto_in_a_bits_address[6:3] == 4'h4 & _out_out_bits_data_WIRE_8 & (&out_backMask))	// @[Cat.scala:33:92, OneHot.scala:57:35, RegisterRouter.scala:83:24]
      ikey1 <= auto_in_a_bits_data;	// @[AES.scala:67:19]
    if (_out_wofireMux_T_2 & auto_in_a_bits_address[6:3] == 4'h5 & _out_out_bits_data_WIRE_8 & (&out_backMask))	// @[Cat.scala:33:92, OneHot.scala:57:35, RegisterRouter.scala:83:24]
      imsg0 <= auto_in_a_bits_data;	// @[AES.scala:68:19]
    if (_out_wofireMux_T_2 & auto_in_a_bits_address[6:3] == 4'h6 & _out_out_bits_data_WIRE_8 & (&out_backMask))	// @[Cat.scala:33:92, OneHot.scala:57:35, RegisterRouter.scala:83:24]
      imsg1 <= auto_in_a_bits_data;	// @[AES.scala:69:19]
    rst_r <= _rst_r_T & active_r;	// @[AES.scala:79:20, :84:25, :91:15, :115:31]
    init_r <= state == 3'h1;	// @[AES.scala:80:20, :89:22, :92:11, :116:20]
    if (_out_wofireMux_T_2 & auto_in_a_bits_address[6:3] == 4'h1 & _out_out_bits_data_WIRE_8 & auto_in_a_bits_mask[0])	// @[AES.scala:113:52, Bitwise.scala:28:17, Cat.scala:33:92, RegisterRouter.scala:83:24]
      mode_r <= auto_in_a_bits_data[0];	// @[AES.scala:81:20, RegisterRouter.scala:83:24]
    enc_r <= _enc_r_T;	// @[AES.scala:82:20, :113:26]
    active_r <= _out_wofireMux_T_2 & auto_in_a_bits_address[6:3] == 4'h0 & _out_out_bits_data_WIRE_8 & auto_in_a_bits_mask[0];	// @[AES.scala:84:25, :85:26, Bitwise.scala:28:17, Cat.scala:33:92, RegisterRouter.scala:83:24]
    if (reset) begin
      counter_r <= 4'h0;	// @[AES.scala:85:26]
      state <= 3'h0;	// @[AES.scala:89:22]
    end
    else begin
      if (_enc_r_T)	// @[AES.scala:113:26]
        counter_r <= 4'h0;	// @[AES.scala:85:26]
      else	// @[AES.scala:113:26]
        counter_r <= counter_r + 4'h1;	// @[AES.scala:85:26, :113:52]
      if (_rst_r_T & active_r)	// @[AES.scala:84:25, :91:{15,26}]
        state <= 3'h1;	// @[AES.scala:89:22, :92:11]
      else if (state == 3'h1) begin	// @[AES.scala:89:22, :92:11, :93:22]
        if (&counter_r)	// @[AES.scala:85:26, :94:21]
          state <= 3'h2;	// @[AES.scala:89:22, :95:13]
        else	// @[AES.scala:94:21]
          state <= 3'h1;	// @[AES.scala:89:22, :92:11]
      end
      else if (state == 3'h2)	// @[AES.scala:89:22, :95:13, :99:22]
        state <= 3'h3;	// @[AES.scala:89:22, :100:11]
      else if (state == 3'h3) begin	// @[AES.scala:89:22, :100:11, :101:22]
        if (_impl_o_finish)	// @[AES.scala:76:20]
          state <= 3'h4;	// @[AES.scala:89:22, :103:13]
        else	// @[AES.scala:76:20]
          state <= 3'h3;	// @[AES.scala:89:22, :100:11]
      end
      else	// @[AES.scala:101:22]
        state <= 3'h0;	// @[AES.scala:89:22]
    end
  end // always @(posedge)
  `ifndef SYNTHESIS
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM_0;
    logic [31:0] _RANDOM_1;
    logic [31:0] _RANDOM_2;
    logic [31:0] _RANDOM_3;
    logic [31:0] _RANDOM_4;
    logic [31:0] _RANDOM_5;
    logic [31:0] _RANDOM_6;
    logic [31:0] _RANDOM_7;
    logic [31:0] _RANDOM_8;
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM_0 = `RANDOM;
        _RANDOM_1 = `RANDOM;
        _RANDOM_2 = `RANDOM;
        _RANDOM_3 = `RANDOM;
        _RANDOM_4 = `RANDOM;
        _RANDOM_5 = `RANDOM;
        _RANDOM_6 = `RANDOM;
        _RANDOM_7 = `RANDOM;
        _RANDOM_8 = `RANDOM;
        ikey0 = {_RANDOM_0, _RANDOM_1};	// @[AES.scala:66:19]
        ikey1 = {_RANDOM_2, _RANDOM_3};	// @[AES.scala:67:19]
        imsg0 = {_RANDOM_4, _RANDOM_5};	// @[AES.scala:68:19]
        imsg1 = {_RANDOM_6, _RANDOM_7};	// @[AES.scala:69:19]
        rst_r = _RANDOM_8[0];	// @[AES.scala:79:20]
        init_r = _RANDOM_8[1];	// @[AES.scala:79:20, :80:20]
        mode_r = _RANDOM_8[2];	// @[AES.scala:79:20, :81:20]
        enc_r = _RANDOM_8[3];	// @[AES.scala:79:20, :82:20]
        active_r = _RANDOM_8[4];	// @[AES.scala:79:20, :84:25]
        counter_r = _RANDOM_8[8:5];	// @[AES.scala:79:20, :85:26]
        state = _RANDOM_8[11:9];	// @[AES.scala:79:20, :89:22]
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // not def SYNTHESIS
  aes_bb impl (	// @[AES.scala:76:20]
    .i_clk        (clock),
    .i_rst        (reset | rst_r),	// @[AES.scala:79:20, :123:33]
    .i_init       (init_r),	// @[AES.scala:80:20]
    .i_mode       (mode_r),	// @[AES.scala:81:20]
    .i_enc        (enc_r),	// @[AES.scala:82:20]
    .i_key_AES    ({ikey1, ikey0}),	// @[AES.scala:66:19, :67:19, Cat.scala:33:92]
    .i_msg_AES    ({imsg1, imsg0}),	// @[AES.scala:68:19, :69:19, Cat.scala:33:92]
    .o_cipher_AES (_impl_o_cipher_AES),
    .o_finish     (_impl_o_finish)
  );
  assign auto_in_a_ready = auto_in_d_ready;
  assign auto_in_d_valid = auto_in_a_valid;
  assign auto_in_d_bits_opcode = {2'h0, out_front_bits_read};	// @[RegisterRouter.scala:72:36, :98:19]
  assign auto_in_d_bits_size = auto_in_a_bits_size;
  assign auto_in_d_bits_source = auto_in_a_bits_source;
  assign auto_in_d_bits_data = _GEN[auto_in_a_bits_address[6:3]] ? _GEN_0[auto_in_a_bits_address[6:3]] : 64'h0;	// @[Cat.scala:33:92, MuxLiteral.scala:49:10, RegisterRouter.scala:83:24]
endmodule

